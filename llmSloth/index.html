<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LLM Sloth</title>
  <link rel="icon" href="favicon.png" type="image/x-icon">
    <link rel="stylesheet" href="styles.css"> 
</head>
<body>
  <!-- ADDED CONTAINER AND BUTTON FOR COPY SOURCE -->
  <div id="copy-catbox-source-container">
    <button id="copy-catbox-source-button"></button>
  </div>

  <!-- ADDED RECENT CHATS SIDEBAR -->
  <aside id="recent-chats-sidebar"> 
    <ul id="recent-chats-list">
      <!-- Populated by JavaScript -->
    </ul>
  </aside>

  <aside class="sidebar-layout">
    <div class="counter_holder">
      <div class="counter" id="counter"><span id="counter-text-span">0/0</span></div>
    </div>
    <div id="time_column_container"></div>
  </aside>
  <main id="content-layout">
            <div id="title"> </div>
        <div id="brown">
            <div id="chat-id-link-container"></div>
            <div id="content"></div>
    </div>
  </main>
  <div id="github-stats-sidebar">
    <p><strong>Last commit:</strong> <span id="gh-stats-last-commit" class="gh-stats-loading">Loading...</span></p>
    <p><strong>Past month:</strong> <span id="gh-stats-commits-month" class="gh-stats-loading">Loading...</span> commits</p>
    <p><strong>Unique repos:</strong> <span id="gh-stats-repos-pushed" class="gh-stats-loading">Loading...</span></p>
    <p><strong>Commit messages:</strong></p>
    <ul id="gh-stats-commit-messages"><li class="gh-stats-loading">Loading...</li></ul>
  </div>
  <div class="custom-notification" id="custom-notification-fallback"></div>
  <img src="https://em-content.zobj.net/source/google/223/sloth_1f9a5.png" class="sloth-img" id="sloth-top-right">

  <!-- SCRIPT FOR RECENT CHATS SIDEBAR -->
  <script>
    // === Recent Chats Sidebar Logic ===
    (function() {
        const RECENT_CHATS_LS_KEY = 'llmSlothRecentChats';
        const MAX_RECENT_CHATS_COUNT = 15;
        const CHAT_PAGE_BASE_URL = 'https://leafstrat.github.io/llmSloth/'; // As per requirement

        // Function to save chat details to local storage
        function saveRecentChat(chatId, chatTitle, timestamp) {
            if (!chatId || !chatTitle) {
                console.warn('Attempted to save recent chat with missing ID or Title for ID:', chatId);
                return;
            }

            let chats = [];
            try {
                const storedChats = localStorage.getItem(RECENT_CHATS_LS_KEY);
                if (storedChats) {
                    chats = JSON.parse(storedChats);
                }
            } catch (e) {
                console.error('Failed to parse recent chats from localStorage:', e);
                localStorage.removeItem(RECENT_CHATS_LS_KEY); // Clear corrupted data
            }

            // Remove existing entry for this chatId to move it to the top/update it
            chats = chats.filter(chat => chat.id !== chatId);

            // Add new/updated chat to the beginning of the array
            chats.unshift({
                id: chatId,
                title: chatTitle,
                date: timestamp || new Date().toISOString() // Use provided timestamp or current time
            });

            // Keep only the most recent chats
            chats = chats.slice(0, MAX_RECENT_CHATS_COUNT);

            try {
                localStorage.setItem(RECENT_CHATS_LS_KEY, JSON.stringify(chats));
            } catch (e) {
                console.error('Failed to save recent chats to localStorage:', e);
            }
        }

        // Expose the save function so the main script can call it
        window.llmSlothFeatures = window.llmSlothFeatures || {};
        window.llmSlothFeatures.addRecentChat = saveRecentChat;

        // Function to display recent chats in the sidebar
        function displayRecentChats() {
            const recentChatsListElement = document.getElementById('recent-chats-list');
            if (!recentChatsListElement) {
                console.error('Recent chats list element (#recent-chats-list) not found.');
                return;
            }

            let chats = [];
            try {
                const storedChats = localStorage.getItem(RECENT_CHATS_LS_KEY);
                if (storedChats) {
                    chats = JSON.parse(storedChats);
                }
            } catch (e) {
                console.error('Failed to parse recent chats from localStorage for display:', e);
            }

            // Sort chats by date, most recent first
            chats.sort((a, b) => new Date(b.date) - new Date(a.date));

            recentChatsListElement.innerHTML = ''; // Clear any existing list items

            if (chats.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No recent chats.';
                li.className = 'no-chats-message'; // Apply class for styling
                recentChatsListElement.appendChild(li);
                return;
            }

            const currentUrlParams = new URLSearchParams(window.location.search);
            const currentChatId = currentUrlParams.get('id');

            chats.forEach(chat => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                
                a.href = `${CHAT_PAGE_BASE_URL}?id=${chat.id}`;
                a.textContent = chat.title || `Chat: ${chat.id}`; // Fallback if title is somehow null/empty
                a.title = `${chat.title || 'Untitled Chat'} (ID: ${chat.id})\nViewed: ${new Date(chat.date).toLocaleString()}`;
                
                // Highlight the link if it matches the currently viewed chat
                if (chat.id === currentChatId) {
                    a.classList.add('active-chat-link');
                }

                li.appendChild(a);
                recentChatsListElement.appendChild(li);
            });
        }

        // Populate the recent chats sidebar when the DOM is ready
        document.addEventListener('DOMContentLoaded', displayRecentChats);
    })();
  </script>

  <script>
    // Script-level global variables (IIFE will close over these)
    let slothElement, githubStatsSidebarElement;
    let lastScrollPositionBeforeFullscreen = 0;
    let navigableItems = [];
    let currentIndex = 0;
    let totalNavigable = 0;
    let CODEBLOCK_MAX_HEIGHT_PX;
    // initialTimestampDate and secondsUpdateInterval are now moved into the IIFE

    (async function () {
      // IIFE-scoped state for time column
      let initialTimestampDate;
      let secondsUpdateInterval;

      const PARAMS_ID_KEY = 'id';
      const MISSING_ID_MESSAGE = 'Missing ?id=...';
      const CATBOX_URL_PREFIX = 'https://files.catbox.moe/';
      const CATBOX_URL_SUFFIX = '.json';
      const DEFAULT_DOCUMENT_TITLE = 'LLM Sloth';
      const NO_MESSAGES_ERROR = 'No messages found or data format is incorrect.';
      const NAV_ITEM_PREFIX = 'nav-item-';
      const SCROLL_VIEW_OFFSET_PX = 30;
      const EXPAND_SCROLL_DEBOUNCE_MS = 50;
      const LAYOUT_CALC_DEBOUNCE_MS = 0;
      const NOTIFICATION_FALLBACK_TIMEOUT_MS = 3000;
      const NOTIFICATION_BODY_MAX_LENGTH = 100;
      const COPY_FAIL_TITLE = "Copy Failed";
      const COPY_FAIL_BODY = "Could not copy text to clipboard.";
      const CONSOLE_ERROR_MESSAGE_FOR_COPY_FAIL = "check console for details.";
      const GENERIC_CONTENT_COPIED_BODY = "Content copied.";
      const ICON_PATH = '/favicon.ico';
      const HLJS_RETRY_DELAY_MS = 500;
      const HLJS_MAX_RETRIES = 2;
                const MIN_LINES_FOR_FULLSCREEN = 10;
      const MIN_LOC_TO_SHOW_COUNT = 7;
      const SECONDS_UPDATE_INTERVAL_MS = 10000; // Now correctly scoped

      const MAXIMIZED_CONTENT_MARGIN_LEFT_PERCENT = 15;
      const MAXIMIZED_CONTENT_MARGIN_RIGHT_PERCENT = 0;
      const COMPACT_CONTENT_MARGIN_LEFT_PERCENT = 0;
      const COMPACT_CONTENT_MARGIN_RIGHT_PERCENT = 0;

      document.documentElement.style.setProperty('--content-margin-left-maximized', `${MAXIMIZED_CONTENT_MARGIN_LEFT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-right-maximized', `${MAXIMIZED_CONTENT_MARGIN_RIGHT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-left-compact', `${COMPACT_CONTENT_MARGIN_LEFT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-right-compact', `${COMPACT_CONTENT_MARGIN_RIGHT_PERCENT}%`);

      const params = new URLSearchParams(window.location.search);
      const id = params.get(PARAMS_ID_KEY);
      const contentContainer = document.getElementById('content');
      const counterElement = document.getElementById('counter');
      const counterTextSpan = document.getElementById('counter-text-span');
      const titleElement = document.getElementById('title'); // Defined here
      const brownElement = document.getElementById('brown');
      const chatIdLinkContainer = document.getElementById('chat-id-link-container');

      slothElement = document.getElementById('sloth-top-right');
      githubStatsSidebarElement = document.getElementById('github-stats-sidebar');
      const copyCatboxSourceButton = document.getElementById('copy-catbox-source-button'); // Get the new button

      // --- Time Column Helper Functions (Moved Inside IIFE) ---
      function formatSecondsForDisplay(seconds) {
          if (seconds < 100000) {
            return seconds.toLocaleString(undefined, { useGrouping: true });
          } else {
            const thousands = Math.floor(seconds / 1000);
            return thousands.toLocaleString(undefined, { useGrouping: true }) + 'k';
          }
      }

      function updateLiveSecondsCounter() {
          if (!initialTimestampDate) return; // Guard clause

          const currentDate = new Date();
          const diffTime = Math.abs(currentDate - initialTimestampDate);
          const diffSeconds = Math.floor(diffTime / 1000);

          const secondsValueElement = document.querySelector('.time_column .time_seconds');
          if (secondsValueElement) {
              secondsValueElement.textContent = formatSecondsForDisplay(diffSeconds);
          }
      }

      function createTimeColumn(timestamp) {
        const timeColumn = document.createElement('div');
        timeColumn.className = 'time_column';

        initialTimestampDate = new Date(timestamp); // Store for live updates
        const currentDate = new Date();

        const diffTime = Math.abs(currentDate - initialTimestampDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        const diffSecondsInitial = Math.floor(diffTime / 1000);

        const year = initialTimestampDate.getFullYear();
        const monthNames = ["January", "February", "March", "April", "May", "June",
          "July", "August", "September", "October", "November", "December"
        ];
        const month = monthNames[initialTimestampDate.getMonth()];

        const localHours = initialTimestampDate.getHours();
        const localAMPM = localHours >= 12 ? 'pm' : 'am';
        let displayHours = localHours % 12;
        displayHours = displayHours ? displayHours : 12;
        
        const secondsBlock = document.createElement('div');
        secondsBlock.className = 'time_block';
        secondsBlock.innerHTML = `
          <div class="time_seconds">${formatSecondsForDisplay(diffSecondsInitial)}</div>
          <div class="time_seconds_text">seconds old</div>
        `;

        const daysBlock = document.createElement('div');
        daysBlock.className = 'time_block';
        const daysTextLabel = diffDays === 1 ? "day old" : "days old";
        daysBlock.innerHTML = `
          <div class="time_days">${diffDays}</div>
          <div class="time_days_text">${daysTextLabel}</div>
        `;

        const dateBlock = document.createElement('div');
        dateBlock.className = 'time_block';
        dateBlock.innerHTML = `
          <div class="time_year">${year}</div>
          <div class="time_month">${month}</div>
        `;

        const timeBlock = document.createElement('div');
        timeBlock.className = 'time_block';
        timeBlock.innerHTML = `
          <div class="time_hour">${displayHours}${localAMPM}</div>
        `;

        timeColumn.appendChild(secondsBlock);
        timeColumn.appendChild(daysBlock);
        timeColumn.appendChild(dateBlock);
        timeColumn.appendChild(timeBlock);

        const timeColumnContainer = document.getElementById('time_column_container');
        if (timeColumnContainer) {
            timeColumnContainer.innerHTML = ''; // Clear previous if any
            timeColumnContainer.appendChild(timeColumn);
        }

        if (secondsUpdateInterval) clearInterval(secondsUpdateInterval); // Clear existing interval if any
        secondsUpdateInterval = setInterval(updateLiveSecondsCounter, SECONDS_UPDATE_INTERVAL_MS);
      }
      // --- End of Time Column Helper Functions ---

      if (!id) {
        contentContainer.textContent = MISSING_ID_MESSAGE;
        if (copyCatboxSourceButton) copyCatboxSourceButton.style.display = 'none'; // Hide button if no ID
        return;
      }

      // --- Copy Catbox Source Button Logic ---
      if (copyCatboxSourceButton) { // Check if element exists
          copyCatboxSourceButton.textContent = `files.catbox.moe/${id}.json`;
          copyCatboxSourceButton.addEventListener('click', async () => {
              copyCatboxSourceButton.classList.add('active'); // Visual feedback
              const sourceUrl = `${CATBOX_URL_PREFIX}${id}${CATBOX_URL_SUFFIX}`;
              try {
                  const res = await fetch(sourceUrl);
                  if (!res.ok) {
                      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                  }
                  const sourceData = await res.json();

                  if (sourceData.modelMessages && Array.isArray(sourceData.modelMessages)) {
                      const messagesToCopy = JSON.stringify(sourceData.modelMessages, null, 2);
                      await navigator.clipboard.writeText(`\`\`\`\n${messagesToCopy}\n\`\`\`\n\n`);
                      showBrowserNotification("Source Copied", `Copied ${sourceData.modelMessages.length} message(s) from ${id}.json`);
                  } else {
                      throw new Error("'modelMessages' not found or not an array.");
                  }
              } catch (error) {
                  console.error("Error copying Catbox source:", error);
                  showBrowserNotification(COPY_FAIL_TITLE, `Could not copy: ${error.message}`, true);
              } finally {
                  setTimeout(() => copyCatboxSourceButton.classList.remove('active'), 300); // Remove visual feedback
              }
          });
      }
      // --- End of Copy Catbox Source Button Logic ---

      const url = `${CATBOX_URL_PREFIX}${id}${CATBOX_URL_SUFFIX}`;

      try {
        const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
        const codeblockMaxHeightREMStyle = getComputedStyle(document.documentElement).getPropertyValue('--codeblock-max-height');
        if (codeblockMaxHeightREMStyle) {
            const codeblockMaxHeightREM = parseFloat(codeblockMaxHeightREMStyle.replace('rem', ''));
            CODEBLOCK_MAX_HEIGHT_PX = codeblockMaxHeightREM * rootFontSize;
        } else {
            CODEBLOCK_MAX_HEIGHT_PX = 10 * 16; // Fallback: 10rem * 16px/rem
        }

        const res = await fetch(url);
        if (!res.ok) {
            throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        if (data.timestamp) {
          createTimeColumn(data.timestamp);
        }

        const displayTitle = data.chatTitle && data.chatTitle.trim() !== "" ? data.chatTitle.trim() : DEFAULT_DOCUMENT_TITLE;
        document.title = `${displayTitle} | ${DEFAULT_DOCUMENT_TITLE}`;
        if (titleElement) {
          titleElement.textContent = displayTitle;
        } else {
          console.warn("Title element (#title) not found.");
        }

        if (id && window.llmSlothFeatures && typeof window.llmSlothFeatures.addRecentChat === 'function') {
            window.llmSlothFeatures.addRecentChat(id, displayTitle, data.timestamp);
        }


        if (data.chatId && data.chatId.trim() !== "" && data.chatId.trim().toLowerCase() !== "new_chat") {
            const chatIdLink = document.createElement('a');
            chatIdLink.href = `https://aistudio.google.com/prompts/${data.chatId}`;
            chatIdLink.textContent = `Chat ID: ${data.chatId}`;
            chatIdLink.target = "_blank";
            chatIdLinkContainer.appendChild(chatIdLink);
        }

        contentContainer.innerHTML = '';

        if ("Notification" in window && Notification.permission !== "granted" && Notification.permission !== "denied") {
            Notification.requestPermission().then(permission => {
                if (permission === "granted") console.log("Notification permission granted.");
                else console.log("Notification permission denied.");
            });
        }

        let globalNavIdCounter = 0;

        if (data.modelMessages && Array.isArray(data.modelMessages)) {
            for (const md of data.modelMessages) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-container';
              wrapper.innerHTML = marked.parse(md);

              const codeBlocks = wrapper.querySelectorAll('pre');
              codeBlocks.forEach(preElement => {
                const codeBlockNavId = `${NAV_ITEM_PREFIX}${globalNavIdCounter++}`;
                preElement.dataset.navId = codeBlockNavId;
                preElement.setAttribute('tabindex', '-1');
                navigableItems.push({
                    element: preElement,
                    type: 'codeblock',
                    parentMessageContainer: wrapper,
                    id: codeBlockNavId
                });
              });
              contentContainer.appendChild(wrapper);
            }
        } else {
            contentContainer.textContent = NO_MESSAGES_ERROR;
            return;
        }
        totalNavigable = navigableItems.length;

        function applyHighlighting(retries = HLJS_MAX_RETRIES) {
            if (typeof hljs !== 'undefined' && hljs.highlightElement) {
                document.querySelectorAll('pre code').forEach(block => {
                    hljs.highlightElement(block);
                });
                updateLineCounts();
            } else if (retries > 0) {
                setTimeout(() => applyHighlighting(retries - 1), HLJS_RETRY_DELAY_MS);
            } else {
                updateLineCounts(); 
            }
        }

                applyHighlighting();

        function updateLineCounts() {
            document.querySelectorAll('pre[data-nav-id] code').forEach(codeElement => {
                const preElement = codeElement.closest('pre[data-nav-id]');
                if (preElement) {
                    const numLines = (codeElement.textContent || '').split('\n').length;
                    preElement.dataset.lineCount = numLines;

                    if (numLines < MIN_LOC_TO_SHOW_COUNT) {
                        preElement.dataset.locCountHidden = "true";
                    } else {
                        preElement.removeAttribute('data-loc-count-hidden');
                    }
                }
            });
        }

        if (id && totalNavigable > 0) {
            const savedIndex = localStorage.getItem(`llmReader_pos_${id}`);
            if (savedIndex !== null) {
                const parsedIndex = parseInt(savedIndex, 10);
                if (!isNaN(parsedIndex) && parsedIndex >= 0 && parsedIndex < totalNavigable) {
                    currentIndex = parsedIndex;
                }
            }
        }

        updateCounter();

        if (totalNavigable > 0) {
            highlightItem(currentIndex);
            setTimeout(() => scrollToItem(currentIndex), LAYOUT_CALC_DEBOUNCE_MS > 0 ? LAYOUT_CALC_DEBOUNCE_MS + 20 : 70); // Default smooth scroll on load
        }

        document.addEventListener('keydown', (event) => {
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

          const isFullscreen = document.body.classList.contains('fullscreen-codeblock-active');
          const key = event.key.toLowerCase();

          if (key === 'pagedown' || key === 'j') {
            if (isFullscreen) return;
            event.preventDefault();
            navigateNext();
          } else if (key === 'pageup' || key === 'k') {
            if (isFullscreen) return;
            event.preventDefault();
            navigatePrevious();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            toggleExpandCurrent();
          }
        });

        contentContainer.addEventListener('click', (e) => {
            let targetElement = e.target;
            let navId = null;

            while (targetElement && targetElement !== contentContainer) {
                if (targetElement.dataset && targetElement.dataset.navId && targetElement.tagName === 'PRE') {
                    navId = targetElement.dataset.navId;
                    break;
                }
                targetElement = targetElement.parentElement;
            }

            if (navId) {
                const newIndex = navigableItems.findIndex(item => item.id === navId);
                if (newIndex !== -1) {
                    currentIndex = newIndex;
                    highlightItem(currentIndex);
                    updateCounter();
                    copyCurrentItem();
                    scrollToItem(currentIndex); // Default smooth scroll on click
                }
            }
        });

        function navigateNext() {
          if (totalNavigable === 0 || currentIndex >= totalNavigable - 1) return;
          currentIndex++;
          highlightItem(currentIndex);
          updateCounter();
          copyCurrentItem();
          scrollToItem(currentIndex); // Default smooth scroll
        }

        function navigatePrevious() {
          if (totalNavigable === 0 || currentIndex <= 0) return;
          currentIndex--;
          highlightItem(currentIndex);
          updateCounter();
          copyCurrentItem();
          scrollToItem(currentIndex); // Default smooth scroll
        }

        function highlightItem(index) {
          navigableItems.forEach(item => {
            item.element.classList.remove('nav-active');
          });
          if (navigableItems[index]) {
            navigableItems[index].element.classList.add('nav-active');
          }
        }

        function updateCounter() {
          counterTextSpan.textContent = `${totalNavigable > 0 ? currentIndex + 1 : 0}/${totalNavigable}`;
          if (totalNavigable > 0) {
            if (!counterElement.classList.contains('loaded')) {
                counterElement.classList.add('loaded');
            }
            if(!counterTextSpan.classList.contains('loaded')) {
                counterTextSpan.classList.add('loaded');
            }
            if (id) {
                localStorage.setItem(`llmReader_pos_${id}`, currentIndex);
            }
          } else {
            counterElement.classList.remove('loaded');
            counterTextSpan.classList.remove('loaded');
          }
        }

        // MODIFIED: Added behavior parameter, defaults to 'smooth'
        function scrollToItem(index, behavior = 'smooth') {
            if (index < 0 || index >= totalNavigable || !navigableItems[index]) return;

            const item = navigableItems[index];
            const elementToScrollTo = item.element;

            const rect = elementToScrollTo.getBoundingClientRect();
            const viewportTop = SCROLL_VIEW_OFFSET_PX;
            const viewportBottom = window.innerHeight - (SCROLL_VIEW_OFFSET_PX / 2);

            if (rect.top < viewportTop || rect.bottom > viewportBottom || rect.height === 0) {
                 window.scrollTo({ top: window.pageYOffset + rect.top - viewportTop, behavior: behavior });
            }
        }

        function copyCurrentItem() {
          if (currentIndex >= 0 && currentIndex < totalNavigable) {
            const currentItem = navigableItems[currentIndex];
            let textToCopy = "";
            let notificationTitle = "";

            const codeElement = currentItem.element.querySelector('code');
            textToCopy = codeElement ? codeElement.textContent : currentItem.element.textContent;
            notificationTitle = "Code block copied!";

            if (textToCopy) {
              navigator.clipboard.writeText(textToCopy)
                .then(() => {
                  const firstLine = textToCopy.split('\n')[0].substring(0, NOTIFICATION_BODY_MAX_LENGTH) + (textToCopy.split('\n')[0].length > NOTIFICATION_BODY_MAX_LENGTH ? '...' : '');
                  showBrowserNotification(notificationTitle, firstLine); // MODIFIED: Uncommented
                })
                .catch(err => {
                  console.error("Failed to copy to clipboard:", err);
                  showBrowserNotification(COPY_FAIL_TITLE, COPY_FAIL_BODY, true);
                });
            }
          }
        }

        async function showBrowserNotification(title, bodyText, isError = false) {
          const notificationBody = bodyText || (isError ? CONSOLE_ERROR_MESSAGE_FOR_COPY_FAIL : GENERIC_CONTENT_COPIED_BODY);
          if (!("Notification" in window)) {
            showCustomFallbackNotification(title, notificationBody);
            return;
          }
          if (Notification.permission === "granted") {
            new Notification(title, { body: notificationBody, icon: ICON_PATH });
          } else if (Notification.permission !== "denied") {
            const permission = await Notification.requestPermission();
            if (permission === "granted") {
              new Notification(title, { body: notificationBody, icon: ICON_PATH });
            } else {
              showCustomFallbackNotification(title, notificationBody);
            }
          } else {
            showCustomFallbackNotification(title, notificationBody);
          }
        }

        function showCustomFallbackNotification(message, firstLine) {
          const notificationElement = document.getElementById('custom-notification-fallback');
          if (notificationElement) {
            notificationElement.innerHTML = `<strong>${message}</strong><br><span style="font-size: smaller;">${firstLine || ''}</span>`;
            notificationElement.classList.add('show');
            setTimeout(() => {
              notificationElement.classList.remove('show');
            }, NOTIFICATION_FALLBACK_TIMEOUT_MS);
          }
        }

    function hideNonAncestorsOrTarget(currentDomElement, targetDomElement) {
        if (currentDomElement === targetDomElement) {
            return;
        }
        Array.from(currentDomElement.children).forEach(child => {
            if (child.tagName === 'STYLE' || child.tagName === 'SCRIPT') return;
            if (child === targetDomElement || child.contains(targetDomElement)) {
                hideNonAncestorsOrTarget(child, targetDomElement);
            } else {
                child.classList.add('hidden-by-fullscreen-sibling');
            }
        });
    }

    // MODIFIED: toggleExpandCurrent for fullscreen behavior
    function toggleExpandCurrent() {
        if (currentIndex < 0 || currentIndex >= totalNavigable) return;
        const currentItem = navigableItems[currentIndex];
        const elementToToggle = currentItem.element;

        const expandedClass = 'codeblock-expanded';
        const isCurrentlyExpanded = elementToToggle.classList.contains(expandedClass);
        const isOverflowing = elementToToggle.scrollHeight > CODEBLOCK_MAX_HEIGHT_PX;

        const codeElement = elementToToggle.querySelector('code');
        const numLines = codeElement ? (codeElement.textContent || '').split('\n').length : 0;
        const canGoFullscreen = numLines > MIN_LINES_FOR_FULLSCREEN;

        if (!isOverflowing && !isCurrentlyExpanded && !canGoFullscreen) {
            return;
        }

        const wasFullscreenBeforeToggle = document.body.classList.contains('fullscreen-codeblock-active') &&
                                        elementToToggle.classList.contains('fullscreen-active-item');

        elementToToggle.classList.toggle(expandedClass);
        const isNowExpandedAfterToggle = elementToToggle.classList.contains(expandedClass);

        if (canGoFullscreen) {
            const parentMessageContainer = currentItem.parentMessageContainer;
            const contentRoot = document.getElementById('content');

            if (isNowExpandedAfterToggle) { // Entering fullscreen or re-expanding in fullscreen
                if (!wasFullscreenBeforeToggle) { // Entering fullscreen for the first time
                    lastScrollPositionBeforeFullscreen = window.pageYOffset;
                    document.body.classList.add('fullscreen-codeblock-active');
                    if (slothElement) slothElement.classList.add('hidden-by-fullscreen');
                    if (githubStatsSidebarElement) githubStatsSidebarElement.classList.add('hidden-by-fullscreen');
                    if (titleElement) titleElement.classList.add('hidden-by-fullscreen'); // HIDE TITLE
                    // ADDED: Hide new button and recent chats sidebar in fullscreen
                    const copySourceContainer = document.getElementById('copy-catbox-source-container');
                    const recentChatsSidebar = document.getElementById('recent-chats-sidebar');
                    if (copySourceContainer) copySourceContainer.classList.add('hidden-by-fullscreen');
                    if (recentChatsSidebar) recentChatsSidebar.classList.add('hidden-by-fullscreen');

                    elementToToggle.classList.add('fullscreen-active-item');
                    if (parentMessageContainer) parentMessageContainer.classList.add('fullscreen-parent-active');
                    
                    Array.from(contentRoot.children).forEach(childOfContent => {
                        if (childOfContent !== parentMessageContainer) {
                           childOfContent.classList.add('hidden-by-fullscreen');
                        }
                    });
                    if (parentMessageContainer) {
                        hideNonAncestorsOrTarget(parentMessageContainer, elementToToggle);
                    }
                    
                    // MODIFIED: Immediate scroll to top, no timeout
                    window.scrollTo({ top: 0, behavior: 'auto' }); 
                    elementToToggle.scrollTop = 0; 
                    elementToToggle.focus({ preventScroll: true });

                } else { // Already in fullscreen, just re-expanding
                    setTimeout(() => { // Keep small delay for focus/scrollTop *within* fullscreen
                        elementToToggle.scrollTop = 0;
                        elementToToggle.focus({ preventScroll: true });
                    }, EXPAND_SCROLL_DEBOUNCE_MS);
                }
            } else { // Collapsing
                if (wasFullscreenBeforeToggle) { // Exiting fullscreen
                    document.body.classList.remove('fullscreen-codeblock-active');
                    if (slothElement) slothElement.classList.remove('hidden-by-fullscreen');
                    if (githubStatsSidebarElement) githubStatsSidebarElement.classList.remove('hidden-by-fullscreen');
                    if (titleElement) titleElement.classList.remove('hidden-by-fullscreen'); // SHOW TITLE
                    // ADDED: Show new button and recent chats sidebar when exiting fullscreen
                    const copySourceContainer = document.getElementById('copy-catbox-source-container');
                    const recentChatsSidebar = document.getElementById('recent-chats-sidebar');
                    if (copySourceContainer) copySourceContainer.classList.remove('hidden-by-fullscreen');
                    if (recentChatsSidebar) recentChatsSidebar.classList.remove('hidden-by-fullscreen');

                    elementToToggle.classList.remove('fullscreen-active-item');
                    if (parentMessageContainer) parentMessageContainer.classList.remove('fullscreen-parent-active');
                    
                    document.querySelectorAll('.hidden-by-fullscreen, .hidden-by-fullscreen-sibling').forEach(el => {
                        el.classList.remove('hidden-by-fullscreen');
                        el.classList.remove('hidden-by-fullscreen-sibling');
                    });

                    elementToToggle.focus({ preventScroll: true });
                    // MODIFIED: Immediate jump back to position, then immediate scroll to item if needed
                    window.scrollTo({ top: lastScrollPositionBeforeFullscreen, behavior: 'auto' });
                    scrollToItem(currentIndex, 'auto'); // Use 'auto' behavior

                } else { // Just collapsing, not exiting fullscreen mode (was not fullscreen)
                     elementToToggle.focus({ preventScroll: true });
                     setTimeout(() => scrollToItem(currentIndex), EXPAND_SCROLL_DEBOUNCE_MS); // Smooth scroll if collapsing non-fullscreen
                }
            }
        } else { // Not capable of fullscreen (short code block)
            if (isNowExpandedAfterToggle) { // Expanded
                setTimeout(() => {
                    const rect = elementToToggle.getBoundingClientRect();
                    if (rect.top < SCROLL_VIEW_OFFSET_PX || rect.bottom > window.innerHeight - SCROLL_VIEW_OFFSET_PX / 2) {
                         window.scrollTo({ top: window.pageYOffset + rect.top - SCROLL_VIEW_OFFSET_PX, behavior: 'smooth' });
                    }
                    elementToToggle.focus({ preventScroll: true });
                }, EXPAND_SCROLL_DEBOUNCE_MS);
            
            } else { // Collapsed (short code block, was previously expanded, and not capable of fullscreen)
                elementToToggle.focus({ preventScroll: true });
            }
        }
    } // End of toggleExpandCurrent

      } catch (e) {
        console.error("Error in main IIFE execution:", e); 
        contentContainer.textContent = `Error loading or parsing JSON: ${e.message}`;
        document.title = 'Error Loading Chat';
        if (counterElement) counterElement.classList.remove('loaded');
        if (counterTextSpan) counterTextSpan.classList.remove('loaded');
        if (copyCatboxSourceButton) copyCatboxSourceButton.style.display = 'none'; // Hide button on error too
      }
    })(); // End of main IIFE
  </script>
  <script defer src="marked.min.js"></script>
  <script defer src="highlight.min.js"></script>

  <script>
    // GitHub Stats Sidebar Script (unchanged)
    (function() {
        const GITHUB_API_URL = 'https://gitlook.godoftrickerytestworkers222.workers.dev/';
        const LOCAL_STORAGE_KEY = 'githubUserStats';
        const SIDEBAR_ID = 'github-stats-sidebar';
        const LAST_COMMIT_ID = 'gh-stats-last-commit';
        const COMMITS_MONTH_ID = 'gh-stats-commits-month';
        const REPOS_PUSHED_ID = 'gh-stats-repos-pushed';
        const COMMIT_MESSAGES_ID = 'gh-stats-commit-messages';
        const CRITICAL_TIME_CLASS = 'gh-stats-time-critical';
        const LOADING_CLASS = 'gh-stats-loading';


        function getSidebarElement() {
            const sidebar = document.getElementById(SIDEBAR_ID);
            if (!sidebar) {
                console.error(`GitHub stats sidebar element with ID '${SIDEBAR_ID}' not found in HTML.`);
            }
            return sidebar;
        }

        function isLastCommitOld(lastCommitStr) {
            if (!lastCommitStr || typeof lastCommitStr !== 'string') return false;
            const str = lastCommitStr.toLowerCase();
            const parts = str.split(' ');

            if (parts.length < 2) return false;

            if (str.includes('day') || str.includes('week') || str.includes('month') || str.includes('year')) {
                return true;
            }
            if (str.includes('hour')) {
                const value = parseInt(parts[0], 10);
                if (!isNaN(value) && value > 2) {
                    return true;
                }
            }
            return false;
        }

        function updateSidebarUI(data) {
            const lastCommitEl = document.getElementById(LAST_COMMIT_ID);
            const commitsMonthEl = document.getElementById(COMMITS_MONTH_ID);
            const reposPushedEl = document.getElementById(REPOS_PUSHED_ID);
            const commitMessagesUl = document.getElementById(COMMIT_MESSAGES_ID);

            if (!lastCommitEl || !commitsMonthEl || !reposPushedEl || !commitMessagesUl) {
                console.error("One or more GitHub stats UI elements are missing.");
                return;
            }

            lastCommitEl.textContent = data.last_commit || 'N/A';
            lastCommitEl.classList.remove(LOADING_CLASS);
            if (isLastCommitOld(data.last_commit)) {
