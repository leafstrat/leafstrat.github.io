<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LLM Sloth</title>
  <link rel="icon" href="favicon.png" type="image/x-icon">
  <style>:root
{
    --font-sans: sans-serif;
    --bg-body: #d4dbcc;
    --bg-pre: var(--bg-body);
    --bg-code-block: #f3f3f3;
    --text-main: #444;
    --text-comment: #697070;
    --text-punctuation-tag: rgba(68, 68, 68, 0.667);
    --text-strong-red: #800;
    --text-link-operator: #ab5656;
    --text-literal: #695;
    --text-green-code: #397300;
    --text-meta-blue: #1f7199;
    --text-meta-string-blue: #38a;
    --text-counter: #fff;
    --bg-counter-initial: rgba(0, 0, 0, 0.12);
    --bg-counter-final: #666335;
    --text-time-column: #888;
    --text-notification: #fff;
    --bg-notification: #333;
    --color-active-highlight: #28a745;
    --spacing-unit: 0.5rem;
    --sidebar-width: 7rem; /* 112px if 1rem = 16px */
    --content-padding: calc(var(--spacing-unit) * 3);
    --message-margin-top: 1.25rem;
    --message-padding: 0.1875rem;
    --pre-padding: 0.0625rem;
    --code-block-padding: 1em;
    --inline-code-padding: 0.1875rem 0.3125rem;
    --codeblock-max-height: 10.5rem;
    --counter-padding: 0.3125rem 0.625rem;
    --counter-font-size: 1.075rem;
    --counter-border-radius: 0.9375rem;
    --counter-holder-margin-bottom: 1.25rem;
    --time-block-padding-y: 0.3125rem;
    --time-block-margin-bottom: 0.625rem;
    --notification-padding: 0.625rem 1.25rem;
    --notification-border-radius: 0.3125rem;
    --notification-offset: 1.25rem;
    --content-margin-left-maximized: 15%; /* For wide screens */
    --content-margin-right-maximized: 0%; /* For wide screens */
    --content-margin-left-compact: 0; /* Default for medium/small screens */
    --content-margin-right-compact: 0; /* Default for medium/small screens */
    --sidebar-min-width-squished: 60px; /* Defined tightest point for sidebar-layout, includes padding */
    --sidebar-squished-padding: 5px;
}

/* Global Styles */
*:focus
{
    outline: none !important;
}

body
{
    font-family: var(--font-sans);
    padding: 0;
    margin: 0;
    background: var(--bg-body);
    display: flex;
    min-height: 100vh;
}

/* Layout */
.sidebar-layout
{
    width: var(--sidebar-width);
    padding-top: 2.6rem;
    padding-left: var(--spacing-unit);
    padding-right: var(--spacing-unit);
    padding-bottom: var(--content-padding);
    position: sticky;
    top: 0;
    left: 39px; /* Original offset for wide screens */
    align-self: flex-start;
    max-height: 100vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 100;
    flex-shrink: 0; /* Does not shrink by default */
    box-sizing: border-box;
}

#content-layout
{
    flex-grow: 1; /* Takes available horizontal space */
    margin-left: var(--content-margin-left-compact); /* Default */
    margin-right: var(--content-margin-right-compact); /* Default */
    min-width: 0; /* Crucial for allowing flex items to shrink properly */
    display: flex;
    flex-direction: column;
}

/* Content Elements */
#title
{
    padding: 11px 0px 11px 0px;
    font-size: 30px;
    font-weight: bold;
    color: #666335;
    margin-left: -2px;
    /* Add these lines */
    min-height: 52px; /* Approx padding (11+11) + font-size (30) + line-height buffer */
    line-height: 1.2; /* Explicit line-height */
    box-sizing: border-box; /* Include padding in height calculation */
}

#brown
{
    flex-grow: 1; /* Takes available vertical space within content-layout */
    background-color: #666335;
    /* min-width could be set here if #brown itself needs a minimum drawing space
       before #github-stats-sidebar is removed. For now, relying on content. */
}

/* Counter Component */
.counter_holder
{
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: var(--counter-holder-margin-bottom);
}

.counter
{
    color: var(--text-counter);
    padding: var(--counter-padding);
    font-size: var(--counter-font-size);
    border-radius: var(--counter-border-radius);
}

.counter.loaded
{
    background-color: var(--bg-counter-final);
}

#counter-text-span
{
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
}

#counter-text-span.loaded
{
    opacity: 1;
}

/* Time Column Component */
#time_column_container
{
    width: 100%;
}

.time_column
{
    width: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: var(--text-time-column);
}

.time_block
{
    width: 100%;
    padding: var(--time-block-padding-y) 0;
    text-align: center;
    margin-bottom: var(--time-block-margin-bottom);
}

.time_days,
.time_seconds
{
    font-size: 1.25rem;
    font-weight: 700;
    line-height: 1;
}

.time_days_text,
.time_seconds_text
{
    font-size: 0.625rem;
    line-height: 1;
}

.time_year
{
    font-size: 1.125rem;
    font-weight: 700;
    line-height: 1;
}

.time_month
{
    font-size: 0.75rem;
    line-height: 1;
}

.time_hour
{
    font-size: 1rem;
    line-height: 1;
}

/* Message Container */
.message-container
{
    padding: var(--message-padding);
    margin-bottom: 5px;
    overflow-y: auto;
    overflow-x: hidden;
    position: relative;
    box-sizing: border-box;
}

.message-container pre:first-of-type
{
    border-top: 0px solid #666335;
}

/* Code Blocks & Syntax Highlighting (Highlight.js) */
pre
{
    padding: var(--pre-padding);
    overflow: auto;
    transition: outline .1s, box-shadow .1s, max-height 0.3s ease-in-out;
    margin-top: 0;
    margin-bottom: 0;
    background: var(--bg-pre); 
    overflow-y: hidden;
    position: relative;
}



code.hljs
{
    padding: var(--inline-code-padding);
}

.hljs
{
    background: var(--bg-body); /* Changed from #d4dbcc to var */
    color: var(--text-main);
}

.hljs-tag .hljs-attr,
.hljs-tag .hljs-name
{
    color: var(--text-main);
}

.hljs-comment
{
    color: var(--text-comment);
}

.hljs-punctuation,
.hljs-tag
{
    color: var(--text-punctuation-tag);
}

.hljs-attribute,
.hljs-doctag,
.hljs-keyword,
.hljs-meta .hljs-keyword,
.hljs-name,
.hljs-selector-tag,
.hljs-strong
{
    font-weight: 700;
}

.hljs-deletion,
.hljs-number,
.hljs-quote,
.hljs-selector-class,
.hljs-selector-id,
.hljs-string,
.hljs-template-tag,
.hljs-type
{
    color: var(--text-strong-red);
}

.hljs-section,
.hljs-title
{
    color: var(--text-strong-red);
    font-weight: 700;
}

.hljs-link,
.hljs-operator,
.hljs-regexp,
.hljs-selector-attr,
.hljs-selector-pseudo,
.hljs-symbol,
.hljs-template-variable,
.hljs-variable
{
    color: var(--text-link-operator);
}

.hljs-literal
{
    color: var(--text-literal);
}

.hljs-addition,
.hljs-built_in,
.hljs-bullet,
.hljs-code
{
    color: var(--text-green-code);
}

.hljs-meta
{
    color: var(--text-meta-blue);
}

.hljs-meta .hljs-string
{
    color: var(--text-meta-string-blue);
}

.hljs-emphasis
{
    font-style: italic;
}

/* Navigable Code Blocks (pre[data-nav-id]) */
pre[data-nav-id]
{
    cursor: pointer;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    border-top: 1px solid #666335;
    border-bottom: 0px;
    max-height: 91px;
    overflow: hidden;
}

pre code.hljs
{
    display: block;
    overflow-x: auto; 
		padding-top:3px; 
		padding-bottom:1px;
		padding-left:10px;
		padding-right:10px;
}

pre[data-nav-id]::after
{
    content: "";
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 20px;
    padding-right: 5px;
    padding-top: 5px;
    background: linear-gradient(to right, transparent, #bfafaf1f);
    text-align: center;
    pointer-events: none;
    display: flex;
    align-items: right;
    justify-content: right;
    font-size: 0.8em;
    color: var(--text-main);
    opacity: 0.8;
}

pre[data-nav-id][data-line-count]:not(.codeblock-expanded)::after
{
    content: attr(data-line-count) " LOC";
}

pre[data-nav-id][data-loc-count-hidden="true"]::after
{
    display: none !important;
}

pre[data-nav-id].nav-active
{
    border-color: #666335;
}

pre[data-nav-id].nav-active code.hljs
{
    background: #f0fbe4 !important;
}

/* Expanded Code Blocks */
pre.codeblock-expanded
{
    max-height: none !important;
    overflow-y: auto;
}

pre.codeblock-expanded::after
{
    display: none;
}

/* Notification Component */
.custom-notification
{
    position: fixed;
    bottom: var(--notification-offset);
    right: var(--notification-offset);
    background-color: var(--bg-notification);
    color: var(--text-notification);
    padding: var(--notification-padding);
    border-radius: var(--notification-border-radius);
    transition: opacity .3s;
    opacity: 0;
    z-index: 1000;
    pointer-events: none;
}

.custom-notification.show
{
    opacity: 1;
}

/* Mascot Image */
.sloth-img /* Base style for sloth, display state controlled by media queries */
{
    position: fixed;
    width: 220px;
    height: 220px;
    z-index: -1;
    pointer-events: none;
    display: block; /* Default to visible, hidden by narrower media query */
}

#sloth-top-right
{
    top: 40px;
    left: 98px;
}

/* Fullscreen Mode Styles */
body.fullscreen-codeblock-active
{
    background-color: var(--bg-body);
}

body.fullscreen-codeblock-active .sidebar-layout
{
    display: none !important;
}

body.fullscreen-codeblock-active #content-layout
{
    margin-left: var(--content-margin-left-compact) !important;
    margin-right: var(--content-margin-right-compact) !important;
    max-width: 100%;
}

body.fullscreen-codeblock-active .fullscreen-parent-active
{
    margin: 0 !important;
    /* margin-left: 297px !important; /* This value might need to be dynamic or re-evaluated - Commented out as it might conflict with full width */
    padding: 0 !important;
    border: none !important;
    display: block !important;
}

body.fullscreen-codeblock-active .fullscreen-active-item
{
    margin: 0 !important;
    border: 1px solid #666335 !important;
    box-sizing: border-box;
    display: block !important;
}

body.fullscreen-codeblock-active pre[data-nav-id]::after
{
    display: none;
}

.hidden-by-fullscreen,
.hidden-by-fullscreen-sibling
{
    display: none !important;
}

/*
body.fullscreen-codeblock-active #sloth-top-right
{
    display: block !important; /* Sloth can be visible in fullscreen if desired - This is now controlled by JS and .hidden-by-fullscreen */
/*    z-index: 10;
}
*/

/* GitHub Stats Sidebar specific styles */
#github-stats-sidebar
{
    height: auto; /* Allow content to define height */
    width: 312px;
    min-width: 312px; /* Prevent shrinking beyond this */
    padding-top:52px;
    font-size: 14px;
    color: #666335;
    flex-shrink: 0; /* Ensures it doesn't shrink in the flex layout */
    /* position: sticky; top: 0; align-self: flex-start; max-height: 100vh; */ /* Optional sticky behavior */
    /* overflow-y: auto; */ /* Optional if content can exceed viewport height */
}

#github-stats-sidebar ul li:nth-of-type(odd)::before {
    content: "⬭";
}
#github-stats-sidebar ul li:nth-of-type(even)::before {
    content: "⬬";
}

#github-stats-sidebar ul li::before {
    padding-right: 5px;
}

#github-stats-sidebar p {
    padding-left:20px;
    margin: 6.7px 0;
}
#gh-stats-commit-messages li:nth-of-type(odd) {color:#555;}
#gh-stats-commit-messages li:nth-of-type(even) {color:#666335;}

#gh-stats-commit-messages li {font-size:11px;}

#github-stats-sidebar strong {
    font-weight: 600;
}
#github-stats-sidebar ul {
    list-style-type: none;
    padding-left: 0;
    margin: 8px 0 0 0;
}
#github-stats-sidebar ul li {
    margin-bottom: 4px;
    padding-left: 33px;
    padding-right: 33px;
    text-indent: -13px;
    word-break: break-word;
    padding-top:11px;
    padding-bottom:9px;
    border-top:1px solid #b3b19360;
}

.gh-stats-time-critical {
    color: #D32F2F !important;
    font-weight: bold !important;
}
.gh-stats-loading {
    font-style: italic;
}


/* Media Queries */

/* Styles for very wide screens (original behavior) */
@media (min-width: 1360px)
{
    #content-layout:not(body.fullscreen-codeblock-active #content-layout)
    {
        margin-left: var(--content-margin-left-maximized);
        margin-right: var(--content-margin-right-maximized);
    }

    /* Sloth is visible by default due to .sloth-img base style */
    /* .sidebar-layout retains its default wide-screen styles */

    /* Ensure fullscreen specific overrides are maintained if needed */
    body.fullscreen-codeblock-active #content-layout
    {
        /* margin-left: var(--content-margin-left-maximized) !important; /* Fullscreen should be full width */
        /* margin-right: var(--content-margin-right-maximized) !important; /* Fullscreen should be full width */
        /* padding-left: 113px !important; /* This was in original, might need review for consistency - Fullscreen should be full width */
    }
}

/* Responsive changes as window first starts to get thinner */
@media (max-width: 1359px)
{
    /* Rule: get rid of the sloth */
     /* #sloth-top-right:not(body.fullscreen-codeblock-active #sloth-top-right) - This logic is now primarily handled by JS for fullscreen cases */
    #sloth-top-right
    {
        display: none; /* Default to hidden on smaller screens, JS will manage for fullscreen */
    }
    body.fullscreen-codeblock-active #sloth-top-right.hidden-by-fullscreen { /* Ensure it stays hidden if class is applied */
        display: none !important;
    }


    /* Rule: move sidebar-layout to be attached to the left side of #brown (via viewport)
             and allow it to be crushed */
    .sidebar-layout
    {
        left: 0; /* Attach to viewport edge */
        /* #content-layout already has margin-left:0 by default (compact) at this width,
           so #brown will be to its right. */

        width: auto; /* Allow it to shrink from its original var(--sidebar-width) */
        max-width: var(--sidebar-width); /* But not grow larger than original */
        min-width: var(--sidebar-min-width-squished); /* Its "tightest point" width */
        flex-shrink: 1; /* Allow this flex item to shrink */

        /* Padding for the "5px room on each side" when squished */
        padding-left: var(--sidebar-squished-padding);
        padding-right: var(--sidebar-squished-padding);
    }
    /* #content-layout (containing #brown) will take up space next to the shrinking .sidebar-layout
       because of flex-grow:1. #github-stats-sidebar is still present with its fixed width.
    */
}

/* Further responsive changes: when sidebar-layout is at its tightest point, remove #github-stats-sidebar.
   Breakpoint calculated as:
   min-width of .sidebar-layout (var(--sidebar-min-width-squished))
   + width of #github-stats-sidebar (312px)
   + a minimal conceptual width for #brown (e.g., ~1px to 50px) for #brown to exist before right sidebar is removed.
   Example: 60px + 312px + (let's say) ~3px buffer = 375px.
   At widths <= 375px, #github-stats-sidebar is removed.
*/
@media (max-width: 375px) { /* Adjust this value after testing if it feels off */

    /* Rule: remove the right sidebar, #github-stats-sidebar. */
    #github-stats-sidebar:not(.hidden-by-fullscreen) { /* Allow JS to hide it too for fullscreen */
        display: none;
    }

    /* Rule: now the #brown layout is maximized to the right (within #content-layout which has flex-grow:1) */
    /* Rule: sidebar-layout is squished very compactly (styles from max-width:1359px for min-width and padding still apply) */
}
  </style>
</head>
<body>
  <aside class="sidebar-layout">
    <div class="counter_holder">
      <div class="counter" id="counter"><span id="counter-text-span">0/0</span></div>
    </div>
    <div id="time_column_container"></div>
  </aside>
  <main id="content-layout">
			<div id="title"> </div> 
		<div id="brown">
			<div id="content"></div>
    </div>
  </main>
  <div id="github-stats-sidebar">
    <p><strong>Last commit:</strong> <span id="gh-stats-last-commit" class="gh-stats-loading">Loading...</span></p>
    <p><strong>Past month:</strong> <span id="gh-stats-commits-month" class="gh-stats-loading">Loading...</span> commits</p>
    <p><strong>Unique repos:</strong> <span id="gh-stats-repos-pushed" class="gh-stats-loading">Loading...</span></p>
    <p><strong>Commit messages:</strong></p>
    <ul id="gh-stats-commit-messages"><li class="gh-stats-loading">Loading...</li></ul>
  </div>
  <div class="custom-notification" id="custom-notification-fallback"></div>
  <img src="https://em-content.zobj.net/source/google/223/sloth_1f9a5.png" class="sloth-img" id="sloth-top-right">

  <script>
    // Global scope within IIFE for these elements and state
    let slothElement, githubStatsSidebarElement;
    let lastScrollPositionBeforeFullscreen = 0;
    let navigableItems = [];
    let currentIndex = 0;
    let totalNavigable = 0; // Will be updated after items are processed
    let CODEBLOCK_MAX_HEIGHT_PX; // Will be calculated

    (async function () {
      const PARAMS_ID_KEY = 'id';
      const MISSING_ID_MESSAGE = 'Missing ?id=...';
      const CATBOX_URL_PREFIX = 'https://files.catbox.moe/';
      const CATBOX_URL_SUFFIX = '.json';
      const DEFAULT_DOCUMENT_TITLE = 'LLM Sloth';
      const NO_MESSAGES_ERROR = 'No messages found or data format is incorrect.';
      const NAV_ITEM_PREFIX = 'nav-item-';
      const SCROLL_VIEW_OFFSET_PX = 30;
      const EXPAND_SCROLL_DEBOUNCE_MS = 50;
      const LAYOUT_CALC_DEBOUNCE_MS = 0;
      const NOTIFICATION_FALLBACK_TIMEOUT_MS = 3000;
      const NOTIFICATION_BODY_MAX_LENGTH = 100;
      const COPY_FAIL_TITLE = "Copy Failed";
      const COPY_FAIL_BODY = "Could not copy text to clipboard.";
      const CONSOLE_ERROR_MESSAGE_FOR_COPY_FAIL = "check console for details.";
      const GENERIC_CONTENT_COPIED_BODY = "Content copied.";
      const ICON_PATH = '/favicon.ico';
      const HLJS_RETRY_DELAY_MS = 500;
      const HLJS_MAX_RETRIES = 2;
			const MIN_LINES_FOR_FULLSCREEN = 10;
      const MIN_LOC_TO_SHOW_COUNT = 7;

      const MAXIMIZED_CONTENT_MARGIN_LEFT_PERCENT = 15;
      const MAXIMIZED_CONTENT_MARGIN_RIGHT_PERCENT = 0;
      const COMPACT_CONTENT_MARGIN_LEFT_PERCENT = 0;
      const COMPACT_CONTENT_MARGIN_RIGHT_PERCENT = 0;

      document.documentElement.style.setProperty('--content-margin-left-maximized', `${MAXIMIZED_CONTENT_MARGIN_LEFT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-right-maximized', `${MAXIMIZED_CONTENT_MARGIN_RIGHT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-left-compact', `${COMPACT_CONTENT_MARGIN_LEFT_PERCENT}%`);
      document.documentElement.style.setProperty('--content-margin-right-compact', `${COMPACT_CONTENT_MARGIN_RIGHT_PERCENT}%`);

      const params = new URLSearchParams(window.location.search);
      const id = params.get(PARAMS_ID_KEY);
      const contentContainer = document.getElementById('content');
      const counterElement = document.getElementById('counter');
      const counterTextSpan = document.getElementById('counter-text-span');
      const titleElement = document.getElementById('title'); 

      // Initialize references to elements that will be toggled in fullscreen
      slothElement = document.getElementById('sloth-top-right');
      githubStatsSidebarElement = document.getElementById('github-stats-sidebar');

      if (!id) {
        contentContainer.textContent = MISSING_ID_MESSAGE;
        return;
      }
      const url = `${CATBOX_URL_PREFIX}${id}${CATBOX_URL_SUFFIX}`;

      try {
        const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
        const codeblockMaxHeightREMStyle = getComputedStyle(document.documentElement).getPropertyValue('--codeblock-max-height');
        if (codeblockMaxHeightREMStyle) {
            const codeblockMaxHeightREM = parseFloat(codeblockMaxHeightREMStyle.replace('rem', ''));
            CODEBLOCK_MAX_HEIGHT_PX = codeblockMaxHeightREM * rootFontSize;
        } else {
            CODEBLOCK_MAX_HEIGHT_PX = 10 * 16; // Fallback: 10rem * 16px/rem
        }

        const res = await fetch(url);
        if (!res.ok) {
            throw new Error(`Failed to fetch: ${res.status} ${res.statusText}`);
        }
        const data = await res.json();

        if (data.timestamp) {
          createTimeColumn(data.timestamp);
        }

        // Determine the title string
        const displayTitle = data.chatTitle && data.chatTitle.trim() !== "" ? data.chatTitle.trim() : DEFAULT_DOCUMENT_TITLE;

        // Set both the document title and the H1-like element's text
        document.title = displayTitle;
        if (titleElement) { // <-- Add this block
          titleElement.textContent = displayTitle;
        } else {
          console.warn("Title element (#title) not found.");
        }

        // document.title = data.chatTitle && data.chatTitle.trim() !== "" ? data.chatTitle.trim() : DEFAULT_DOCUMENT_TITLE; // <-- This line is now replaced by the block above
        contentContainer.innerHTML = ''; // Clear existing content *after* setting title
        
        document.title = data.chatTitle && data.chatTitle.trim() !== "" ? data.chatTitle.trim() : DEFAULT_DOCUMENT_TITLE;
        contentContainer.innerHTML = '';

        if ("Notification" in window && Notification.permission !== "granted" && Notification.permission !== "denied") {
            Notification.requestPermission().then(permission => {
                if (permission === "granted") console.log("Notification permission granted.");
                else console.log("Notification permission denied.");
            });
        }

        // navigableItems is already declared in the outer scope
        let globalNavIdCounter = 0;

        if (data.modelMessages && Array.isArray(data.modelMessages)) {
            for (const md of data.modelMessages) {
              const wrapper = document.createElement('div');
              wrapper.className = 'message-container';
              wrapper.innerHTML = marked.parse(md);

              const codeBlocks = wrapper.querySelectorAll('pre');
              codeBlocks.forEach(preElement => {
                const codeBlockNavId = `${NAV_ITEM_PREFIX}${globalNavIdCounter++}`;
                preElement.dataset.navId = codeBlockNavId;
                preElement.setAttribute('tabindex', '-1');
                navigableItems.push({
                    element: preElement,
                    type: 'codeblock',
                    parentMessageContainer: wrapper,
                    id: codeBlockNavId
                });
              });
              contentContainer.appendChild(wrapper);
            }
        } else {
            contentContainer.textContent = NO_MESSAGES_ERROR;
            return;
        }
        totalNavigable = navigableItems.length; // Update global total

        function applyHighlighting(retries = HLJS_MAX_RETRIES) {
            if (typeof hljs !== 'undefined' && hljs.highlightElement) {
                document.querySelectorAll('pre code').forEach(block => {
                    hljs.highlightElement(block);
                });
                updateLineCounts();
            } else if (retries > 0) {
                setTimeout(() => applyHighlighting(retries - 1), HLJS_RETRY_DELAY_MS);
            } else {
                updateLineCounts(); // Still update counts even if highlighting fails
            }
        }

		applyHighlighting();

        function updateLineCounts() {
            document.querySelectorAll('pre[data-nav-id] code').forEach(codeElement => {
                const preElement = codeElement.closest('pre[data-nav-id]');
                if (preElement) {
                    const numLines = (codeElement.textContent || '').split('\n').length;
                    preElement.dataset.lineCount = numLines;

                    if (numLines < MIN_LOC_TO_SHOW_COUNT) {
                        preElement.dataset.locCountHidden = "true";
                    } else {
                        preElement.removeAttribute('data-loc-count-hidden');
                    }
                }
            });
        }

        // currentIndex is already declared in the outer scope
        if (id && totalNavigable > 0) {
            const savedIndex = localStorage.getItem(`llmReader_pos_${id}`);
            if (savedIndex !== null) {
                const parsedIndex = parseInt(savedIndex, 10);
                if (!isNaN(parsedIndex) && parsedIndex >= 0 && parsedIndex < totalNavigable) {
                    currentIndex = parsedIndex;
                }
            }
        }

        updateCounter();

        if (totalNavigable > 0) {
            highlightItem(currentIndex);
            setTimeout(() => scrollToItem(currentIndex), LAYOUT_CALC_DEBOUNCE_MS > 0 ? LAYOUT_CALC_DEBOUNCE_MS + 20 : 70);
        }

        document.addEventListener('keydown', (event) => {
          if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;

          const isFullscreen = document.body.classList.contains('fullscreen-codeblock-active');
          const key = event.key.toLowerCase();

          if (key === 'pagedown' || key === 'j') {
            if (isFullscreen) return;
            event.preventDefault();
            navigateNext();
          } else if (key === 'pageup' || key === 'k') {
            if (isFullscreen) return;
            event.preventDefault();
            navigatePrevious();
          } else if (key === 'c') {
            event.preventDefault();
            copyCurrentItem();
          } else if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            toggleExpandCurrent();
          }
        });

        contentContainer.addEventListener('click', (e) => {
            let targetElement = e.target;
            let navId = null;

            while (targetElement && targetElement !== contentContainer) {
                if (targetElement.dataset && targetElement.dataset.navId && targetElement.tagName === 'PRE') {
                    navId = targetElement.dataset.navId;
                    break;
                }
                targetElement = targetElement.parentElement;
            }

            if (navId) {
                const newIndex = navigableItems.findIndex(item => item.id === navId);
                if (newIndex !== -1) {
                    currentIndex = newIndex;
                    highlightItem(currentIndex);
                    updateCounter();
                    scrollToItem(currentIndex); // Scroll to clicked item
                }
            }
        });

        function navigateNext() {
          if (totalNavigable === 0 || currentIndex >= totalNavigable - 1) return;
          currentIndex++;
          highlightItem(currentIndex);
          updateCounter();
          scrollToItem(currentIndex);
        }

        function navigatePrevious() {
          if (totalNavigable === 0 || currentIndex <= 0) return;
          currentIndex--;
          highlightItem(currentIndex);
          updateCounter();
          scrollToItem(currentIndex);
        }

        function highlightItem(index) {
          navigableItems.forEach(item => {
            item.element.classList.remove('nav-active');
          });
          if (navigableItems[index]) {
            navigableItems[index].element.classList.add('nav-active');
          }
        }

        function updateCounter() {
          counterTextSpan.textContent = `${totalNavigable > 0 ? currentIndex + 1 : 0}/${totalNavigable}`;
          if (totalNavigable > 0) {
            if (!counterElement.classList.contains('loaded')) {
                counterElement.classList.add('loaded');
            }
            if(!counterTextSpan.classList.contains('loaded')) {
                counterTextSpan.classList.add('loaded');
            }
            if (id) {
                localStorage.setItem(`llmReader_pos_${id}`, currentIndex);
            }
          } else {
            counterElement.classList.remove('loaded');
            counterTextSpan.classList.remove('loaded');
          }
        }

        function scrollToItem(index) {
            if (index < 0 || index >= totalNavigable || !navigableItems[index]) return;

            const item = navigableItems[index];
            const elementToScrollTo = item.element;

            const rect = elementToScrollTo.getBoundingClientRect();
            const viewportTop = SCROLL_VIEW_OFFSET_PX;
            const viewportBottom = window.innerHeight - (SCROLL_VIEW_OFFSET_PX / 2);

            if (rect.top < viewportTop || rect.bottom > viewportBottom || rect.height === 0) { // height === 0 for initially hidden/unrendered
                 window.scrollTo({ top: window.pageYOffset + rect.top - viewportTop, behavior: 'smooth' });
            }
        }

        function copyCurrentItem() {
          if (currentIndex >= 0 && currentIndex < totalNavigable) {
            const currentItem = navigableItems[currentIndex];
            let textToCopy = "";
            let notificationTitle = "";

            const codeElement = currentItem.element.querySelector('code');
            textToCopy = codeElement ? codeElement.textContent : currentItem.element.textContent;
            notificationTitle = "Code block copied!";

            if (textToCopy) {
              navigator.clipboard.writeText(textToCopy)
                .then(() => {
                  const firstLine = textToCopy.split('\n')[0].substring(0, NOTIFICATION_BODY_MAX_LENGTH) + (textToCopy.split('\n')[0].length > NOTIFICATION_BODY_MAX_LENGTH ? '...' : '');
                  showBrowserNotification(notificationTitle, firstLine);
                })
                .catch(err => {
                  showBrowserNotification(COPY_FAIL_TITLE, COPY_FAIL_BODY, true);
                });
            }
          }
        }

        async function showBrowserNotification(title, bodyText, isError = false) {
          const notificationBody = bodyText || (isError ? CONSOLE_ERROR_MESSAGE_FOR_COPY_FAIL : GENERIC_CONTENT_COPIED_BODY);
          if (!("Notification" in window)) {
            showCustomFallbackNotification(title, notificationBody);
            return;
          }
          if (Notification.permission === "granted") {
            new Notification(title, { body: notificationBody, icon: ICON_PATH });
          } else if (Notification.permission !== "denied") {
            const permission = await Notification.requestPermission();
            if (permission === "granted") {
              new Notification(title, { body: notificationBody, icon: ICON_PATH });
            } else {
              showCustomFallbackNotification(title, notificationBody);
            }
          } else {
            showCustomFallbackNotification(title, notificationBody);
          }
        }

        function showCustomFallbackNotification(message, firstLine) {
          const notificationElement = document.getElementById('custom-notification-fallback');
          if (notificationElement) {
            notificationElement.innerHTML = `<strong>${message}</strong><br><span style="font-size: smaller;">${firstLine || ''}</span>`;
            notificationElement.classList.add('show');
            setTimeout(() => {
              notificationElement.classList.remove('show');
            }, NOTIFICATION_FALLBACK_TIMEOUT_MS);
          }
        }

    function toggleExpandCurrent() {
        if (currentIndex < 0 || currentIndex >= totalNavigable) return;
        const currentItem = navigableItems[currentIndex];
        const elementToToggle = currentItem.element;

        const expandedClass = 'codeblock-expanded';
        const isCurrentlyExpanded = elementToToggle.classList.contains(expandedClass);
        const isOverflowing = elementToToggle.scrollHeight > CODEBLOCK_MAX_HEIGHT_PX;

        const codeElement = elementToToggle.querySelector('code');
        const numLines = codeElement ? (codeElement.textContent || '').split('\n').length : 0;

        const canGoFullscreen = numLines > MIN_LINES_FOR_FULLSCREEN;

        if (!isOverflowing && !isCurrentlyExpanded && !canGoFullscreen) {
            return; // Nothing to do if not overflowing, not expanded, and can't go fullscreen
        }

        const wasFullscreenBeforeToggle = document.body.classList.contains('fullscreen-codeblock-active') &&
                                        elementToToggle.classList.contains('fullscreen-active-item');

        elementToToggle.classList.toggle(expandedClass);
        const isNowExpandedAfterToggle = elementToToggle.classList.contains(expandedClass);

        if (canGoFullscreen) {
            const parentMessageContainer = currentItem.parentMessageContainer;
            const contentRoot = document.getElementById('content');

            if (isNowExpandedAfterToggle) { // Item is now expanded (or should be)
                if (!wasFullscreenBeforeToggle) { // === ENTERING FULLSCREEN ===
                    lastScrollPositionBeforeFullscreen = window.pageYOffset;

                    document.body.classList.add('fullscreen-codeblock-active');
                    if (slothElement) slothElement.classList.add('hidden-by-fullscreen');
                    if (githubStatsSidebarElement) githubStatsSidebarElement.classList.add('hidden-by-fullscreen');

                    elementToToggle.classList.add('fullscreen-active-item');
                    if (parentMessageContainer) parentMessageContainer.classList.add('fullscreen-parent-active');

                    Array.from(contentRoot.children).forEach(childOfContent => {
                        if (childOfContent !== parentMessageContainer && childOfContent !== elementToToggle) {
                           childOfContent.classList.add('hidden-by-fullscreen');
                        }
                    });
                    if (parentMessageContainer) {
                        Array.from(parentMessageContainer.children).forEach(sibling => {
                            if (sibling !== elementToToggle && sibling.tagName !== 'STYLE' && sibling.tagName !== 'SCRIPT') {
                                sibling.classList.add('hidden-by-fullscreen-sibling');
                            }
                        });
                    }
                    
                    setTimeout(() => {
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        elementToToggle.focus({ preventScroll: true });
                    }, EXPAND_SCROLL_DEBOUNCE_MS);

                } else { // Already in fullscreen, just ensuring it's expanded and visible (e.g. re-toggle)
                    setTimeout(() => {
                        const rect = elementToToggle.getBoundingClientRect();
                        if (rect.top < SCROLL_VIEW_OFFSET_PX || rect.bottom > window.innerHeight - SCROLL_VIEW_OFFSET_PX / 2) {
                            window.scrollTo({ top: window.pageYOffset + rect.top - SCROLL_VIEW_OFFSET_PX, behavior: 'smooth' });
                        }
                        elementToToggle.focus({ preventScroll: true });
                    }, EXPAND_SCROLL_DEBOUNCE_MS);
                }
            } else { // Item is now collapsed
                if (wasFullscreenBeforeToggle) { // === EXITING FULLSCREEN ===
                    document.body.classList.remove('fullscreen-codeblock-active');
                    if (slothElement) slothElement.classList.remove('hidden-by-fullscreen');
                    if (githubStatsSidebarElement) githubStatsSidebarElement.classList.remove('hidden-by-fullscreen');

                    elementToToggle.classList.remove('fullscreen-active-item');
                    if (parentMessageContainer) parentMessageContainer.classList.remove('fullscreen-parent-active');
                    
                    document.querySelectorAll('.hidden-by-fullscreen, .hidden-by-fullscreen-sibling').forEach(el => {
                        el.classList.remove('hidden-by-fullscreen');
                        el.classList.remove('hidden-by-fullscreen-sibling');
                    });

                    elementToToggle.focus({ preventScroll: true });
                    window.scrollTo({ top: lastScrollPositionBeforeFullscreen, behavior: 'auto' }); // Instant scroll
                    
                    setTimeout(() => {
                        scrollToItem(currentIndex); // Smoothly adjust item into view if needed
                    }, EXPAND_SCROLL_DEBOUNCE_MS);

                } else { // Collapsing a large block that was expanded but not in fullscreen mode
                    elementToToggle.focus({ preventScroll: true });
                }
            }
        } else { // Not capable of fullscreen (small code block)
            if (isNowExpandedAfterToggle) { // Expanding a small block
                setTimeout(() => {
                    const rect = elementToToggle.getBoundingClientRect();
                    if (rect.top < SCROLL_VIEW_OFFSET_PX || rect.bottom > window.innerHeight - SCROLL_VIEW_OFFSET_PX / 2) {
                         window.scrollTo({ top: window.pageYOffset + rect.top - SCROLL_VIEW_OFFSET_PX, behavior: 'smooth' });
                    }
                    elementToToggle.focus({ preventScroll: true });
                }, EXPAND_SCROLL_DEBOUNCE_MS);
            } else { // Collapsing a small block
                elementToToggle.focus({ preventScroll: true });
            }
        }
    }

      } catch (e) {
        contentContainer.textContent = `Error loading or parsing JSON: ${e.message}`;
        document.title = 'Error Loading Chat';
        if (counterElement) counterElement.classList.remove('loaded');
        if (counterTextSpan) counterTextSpan.classList.remove('loaded');
      }
    })();

    function createTimeColumn(timestamp) {
      const timeColumn = document.createElement('div');
      timeColumn.className = 'time_column';

      const timestampDate = new Date(timestamp);
      const currentDate = new Date();

      const diffTime = Math.abs(currentDate - timestampDate);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      const diffSeconds = Math.floor(diffTime / 1000);

      const year = timestampDate.getFullYear();
      const monthNames = ["January", "February", "March", "April", "May", "June",
        "July", "August", "September", "october", "November", "December"
      ];
      const month = monthNames[timestampDate.getMonth()];

      const localHours = timestampDate.getHours();
      const localAMPM = localHours >= 12 ? 'pm' : 'am';
      let displayHours = localHours % 12;
      displayHours = displayHours ? displayHours : 12; // the hour '0' should be '12'
      
      const secondsBlock = document.createElement('div');
      secondsBlock.className = 'time_block';

      function formatSeconds(seconds) {
        if (seconds < 100000) {
          return seconds.toLocaleString(undefined, { useGrouping: true });
        } else {
          const thousands = Math.floor(seconds / 1000);
          return thousands.toLocaleString(undefined, { useGrouping: true }) + 'k';
        }
      }

      secondsBlock.innerHTML = `
        <div class="time_seconds">${formatSeconds(diffSeconds)}</div>
        <div class="time_seconds_text">seconds old</div>
      `;

      const daysBlock = document.createElement('div');
      daysBlock.className = 'time_block';
      const daysTextLabel = diffDays === 1 ? "day old" : "days old";
      daysBlock.innerHTML = `
        <div class="time_days">${diffDays}</div>
        <div class="time_days_text">${daysTextLabel}</div>
      `;

      const dateBlock = document.createElement('div');
      dateBlock.className = 'time_block';
      dateBlock.innerHTML = `
        <div class="time_year">${year}</div>
        <div class="time_month">${month}</div>
      `;

      const timeBlock = document.createElement('div');
      timeBlock.className = 'time_block';
      timeBlock.innerHTML = `
        <div class="time_hour">${displayHours}${localAMPM}</div>
      `;

      timeColumn.appendChild(secondsBlock);
      timeColumn.appendChild(daysBlock);
      timeColumn.appendChild(dateBlock);
      timeColumn.appendChild(timeBlock);

      const timeColumnContainer = document.getElementById('time_column_container');
      if (timeColumnContainer) {
          timeColumnContainer.appendChild(timeColumn);
      }
    }
  </script>
  <script defer src="marked.min.js"></script>
  <script defer src="highlight.min.js"></script>

  <script>
    (function() {
        const GITHUB_API_URL = 'https://gitlook.godoftrickerytestworkers222.workers.dev/';
        const LOCAL_STORAGE_KEY = 'githubUserStats';
        const SIDEBAR_ID = 'github-stats-sidebar';
        const LAST_COMMIT_ID = 'gh-stats-last-commit';
        const COMMITS_MONTH_ID = 'gh-stats-commits-month';
        const REPOS_PUSHED_ID = 'gh-stats-repos-pushed';
        const COMMIT_MESSAGES_ID = 'gh-stats-commit-messages';
        const CRITICAL_TIME_CLASS = 'gh-stats-time-critical';
        const LOADING_CLASS = 'gh-stats-loading';


        function getSidebarElement() {
            const sidebar = document.getElementById(SIDEBAR_ID);
            if (!sidebar) {
                console.error(`GitHub stats sidebar element with ID '${SIDEBAR_ID}' not found in HTML.`);
            }
            return sidebar;
        }

        function isLastCommitOld(lastCommitStr) {
            if (!lastCommitStr || typeof lastCommitStr !== 'string') return false;
            const str = lastCommitStr.toLowerCase();
            const parts = str.split(' ');

            if (parts.length < 2) return false;

            if (str.includes('day') || str.includes('week') || str.includes('month') || str.includes('year')) {
                return true;
            }
            if (str.includes('hour')) {
                const value = parseInt(parts[0], 10);
                if (!isNaN(value) && value > 2) {
                    return true;
                }
            }
            return false;
        }

        function updateSidebarUI(data) {
            const lastCommitEl = document.getElementById(LAST_COMMIT_ID);
            const commitsMonthEl = document.getElementById(COMMITS_MONTH_ID);
            const reposPushedEl = document.getElementById(REPOS_PUSHED_ID);
            const commitMessagesUl = document.getElementById(COMMIT_MESSAGES_ID);

            if (!lastCommitEl || !commitsMonthEl || !reposPushedEl || !commitMessagesUl) {
                console.error("One or more GitHub stats UI elements are missing.");
                return;
            }

            lastCommitEl.textContent = data.last_commit || 'N/A';
            lastCommitEl.classList.remove(LOADING_CLASS);
            if (isLastCommitOld(data.last_commit)) {
                lastCommitEl.classList.add(CRITICAL_TIME_CLASS);
            } else {
                lastCommitEl.classList.remove(CRITICAL_TIME_CLASS);
            }

            commitsMonthEl.textContent = data.commits_past_month !== undefined ? data.commits_past_month : 'N/A';
            commitsMonthEl.classList.remove(LOADING_CLASS);
            reposPushedEl.textContent = data.repos_pushed_to !== undefined ? data.repos_pushed_to : 'N/A';
            reposPushedEl.classList.remove(LOADING_CLASS);

            commitMessagesUl.innerHTML = ''; // Clear existing items (e.g., "Loading...")
            if (data.recent_commit_messages && Array.isArray(data.recent_commit_messages) && data.recent_commit_messages.length > 0) {
                data.recent_commit_messages
                  .filter(msg => msg.trim().split(/\s+/).length > 1)
                  .forEach(msg => {
                    const li = document.createElement('li');
                    li.textContent = msg;
                    commitMessagesUl.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'No recent messages.';
                commitMessagesUl.appendChild(li);
            }
        }

        async function fetchAndProcessGitHubStats() {
            try {
                const response = await fetch(GITHUB_API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(data));
                updateSidebarUI(data);
            } catch (error) {
                console.error('Failed to load GitHub stats:', error);
                const commitMessagesUl = document.getElementById(COMMIT_MESSAGES_ID);
                if (commitMessagesUl) {
                    const errorLi = document.createElement('li');
                    errorLi.textContent = 'Failed to load stats.';
                    errorLi.style.color = '#D32F2F';
                    if (commitMessagesUl.firstChild && commitMessagesUl.firstChild.classList && commitMessagesUl.firstChild.classList.contains(LOADING_CLASS)) {
                       commitMessagesUl.innerHTML = '';
                    }
                    // Ensure only one error message if already populated or error shown
                    if (!commitMessagesUl.querySelector('li[style*="color: #D32F2F"]')) {
                        commitMessagesUl.appendChild(errorLi);
                    }
                }
                [LAST_COMMIT_ID, COMMITS_MONTH_ID, REPOS_PUSHED_ID].forEach(id => {
                    const el = document.getElementById(id);
                    if (el && el.classList.contains(LOADING_CLASS)) {
                        el.textContent = 'Error';
                        el.classList.remove(LOADING_CLASS);
                        el.style.color = '#D32F2F';
                    }
                });
            }
        }

        function initGitHubStatsSidebar() {
            const sidebarElement = getSidebarElement();
            if (!sidebarElement) {
                return;
            }

            const cachedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (cachedData) {
                try {
                    updateSidebarUI(JSON.parse(cachedData));
                } catch (e) {
                    console.warn("Failed to parse cached GitHub stats, removing.", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    const commitMessagesUl = document.getElementById(COMMIT_MESSAGES_ID);
                    if(commitMessagesUl) commitMessagesUl.innerHTML = `<li class="${LOADING_CLASS}">Loading...</li>`;
                    [LAST_COMMIT_ID, COMMITS_MONTH_ID, REPOS_PUSHED_ID].forEach(id => {
                        const el = document.getElementById(id);
                        if(el) {
                            el.textContent = 'Loading...';
                            el.classList.add(LOADING_CLASS);
                            el.style.color = '';
                        }
                    });
                }
            }
            fetchAndProcessGitHubStats();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initGitHubStatsSidebar();
        });
    })();
  </script>
</body>
</html>
